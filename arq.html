<!doctype html>
<html lang="pt-br">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Kubernetes</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-0evHe/X+R7YkIZDRvuzKMRqM+OrBnVFBL6DOitfPri4tjfHxaWutUpFmBp4vmVor" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="./style.css"> 
  </head>
  <body>

    <div class="container">
      <header class="d-flex flex-wrap justify-content-center py-3 mb-4 border-bottom">
        <a class="d-flex align-items-center mb-3 mb-md-0 me-md-auto text-dark text-decoration-none">
          <img src="Kubernetes-logo.png" class="logo-img">
          <span class="fs-4">Kubernetes</span>
        </a>
  
        <ul class="nav nav-pills">
          <li class="nav-item"><a href="index.html" class="nav-link">Resumo</a></li>
          <li class="nav-item"><a href="intro.html" class="nav-link">Introdução</a></li>
          <li class="nav-item"><a href="concepts.html" class="nav-link">Componentes</a></li>
          <li class="nav-item"><a href="arq.html" class="nav-link active" aria-current="page">Arquitetura</a></li>
          <li class="nav-item"><a href="#" class="nav-link">Projeto de Exemplo</a></li>
          <li class="nav-item"><a href="#" class="nav-link">Conclusão</a></li>
        </ul>
      </header>
    </div>

    <div class="px-4 py-5 my-5 text-center">
      <img class="d-block mx-auto mb-4" src="./conductor.png" alt="" width="64" height="64">
      <h1 class="display-5 fw-bold">Orquestra</h1>
      <div class="col-lg-6 mx-auto">
        <p class="lead mb-4">
            Kubernetes é frequentemente considerado uma tecnologia complicada e com uma longa linha de aprendizagem. E 
            a sua arquitetura é um dos principais motivos para tais considerações. Isso pois, além de possuir diferentes
            componentes, cada qual com funcionalidades nem sempre triviais, estes componentes trabalham em conjunto, em 
            rotinas não amigáveis à iniciantes. Dessa maneira, um cluster Kubernetes é semelhante a uma orquestra musical (o nome 
            "orquestrador" não é sem propósito): Cada integrante tem seu papel individual, que pode ser analisado 
            e estudado por si só, mas que faz muito mais sentido quando observado ao lado dos outros membros 
            da orquestra. E claro, toda orquestra tem um maestro, que sabe o que esperar de cada integrante 
            e quais comandos dar a eles. Nesta seção, destrincharemos essa arquitetura (ou orquestra), com o objetivo 
            de torna-lá mais simples.
        </p>
        <!-- <div class="d-grid gap-2 d-sm-flex justify-content-sm-center">
          <button type="button" class="btn btn-primary btn-lg px-4 gap-3">Primary button</button>
          <button type="button" class="btn btn-outline-secondary btn-lg px-4">Secondary</button>
        </div> -->
      </div>
    </div>
  
    <div class="b-example-divider"></div>
      <div class="text">
        <h3 class="section-title">Worker Node</h3>
        <p class="lead"> 
          Worker node é o nome dado uma máquina de trabalho (<em>working machine</em>) integrante de um cluster Kubernetes.
          Essas máquinas Podem ser físicas, virtuais (<em>virtual machine - VM</em>) ou uma aplicação em nuvem.
          A principal responsabilidade de um worker node (frequentemente referido apenas como node) é o armazenamento de
          múltiplos Pods. Ou seja, esses componentes são os responsáveis diretos pelo funcionamento da aplicação 
          pela qual o cluster é responsável. Para entender melhor seu funcionamento, detalharemos a seguir os principais
          processos que compõem um worker node. 
        </p> 

        <h5 class="subsection-title">Containers Runtime</h5>
        <p class="lead"> 
            Todo worker node deve possuir um container runtime, como Docker, por exemplo. Isto é esperado já que, como citado,
            o objetivo de um node é cuidar dos Pods, que por sua vez possuem os containers. 
        </p>
        <h5 class="subsection-title">Kubelet</h5>
        <p class="lead"> 
            Kubelet é outro processo de suma importância, presente em todo node. O objetivo desse agente é 
            garantir que os containers de cada Pod estão rodando como esperado. Para isso, o Kubelet toma como
            base PodSpecs (objetos YAML ou JSON que descrevem um Pod) e garante que os 
            containers descritos neles estão rodando como esperado. Cabe também ao Kubelet a tarefa de inicializar 
            um Pod, definindo a quantidade de recursos da máquina que deve ser reservada a ele, como memória e CPU. 
        </p>
        <h5 class="subsection-title">Kube-Proxy</h5>
        <p class="lead">
            Um cluster geralmente possui vários worker nodes, cada um contendo diferentes Pods (ou réplicas de mesmos Pods),
            e que precisam se comunicar entre si. Essa comunicação se dá através de um proxy, chamado de Kube-Proxy. 
            Antes de explicá-lo, vejamos como seria a comunicação entre Pods caso ele não existisse:
        </p>
        <img src="./no-proxy.jpeg" class="mx-auto d-block border my-3 "widht="500" height="300"> 
        <p class="lead">
            Sem Kube-Proxy, um Pod cliente (que faz uma requisição) precisaria conhecer o endereço de IP 
            do Pod servidor (que recebe uma requisição) que desejasse se conectar. Ou seja, cada Pod precisaria formar e manter 
            uma lista de endereços de todos os outros Pods. Isso por si só já é uma carga de trabalho desnecessária para um Pod,
            mas tudo fica ainda mais complicado quando lembramos de seu tempo de vida. Como descrito na seção <a href="./concepts.html">Componentes</a>,
            os Pods são efêmeros. Portanto, espera-se eles sejam criados e destruídos constantemente - frequentemente devido à atualizações na 
            escalabilidade, falhas em hardware e software. Seguindo esse modelo, toda vez que um Pod fosse substituído deveria haver um procedimento de 
            informar a todos os outros Pods o novo endereço de IP. Evidentemente, isso seria computacionalmente custoso.
        </p>
        <p class="lead">
            Mas esse não é o cenário real em um cluster Kubernetes.  
            O Kube-Proxy implementa um serviço que provê comunicação estável: Um controlador observa os Pods que estão 
            associados com determinado serviço
             para adicioná-los e removê-los do seu banco de dados quando necessário. 
            Agora, o cliente só precisa do endereço do serviço, e o resto não é sua responsabilidade.
        </p>
        <img src="./with-proxy.jpeg" class="mx-auto d-block border my-3 "widht="500" height="300"> 
        <p class="lead">
            Em suma, o Kube-proxy é um proxy de rede que é executado em cada nó de seu cluster, 
            implementando parte do conceito de serviço do Kubernetes. 
            O Kube-proxy mantém regras de rede nos nós, que permitem a comunicação de rede com seus Pods a partir de 
            sessões de rede dentro ou fora do cluster.
        </p>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/js/bootstrap.bundle.min.js" integrity="sha384-pprn3073KE6tl6bjs2QrFaJGz5/SUsLqktiwsUTF55Jfv3qYSDhgCecCxMW52nD2" crossorigin="anonymous"></script>
  </body>
</html>


            <!-- A tarefa do Kube-Proxy é criar as regras de acesso de rede para cada um dos serviços de Pod presentes no 
            node. Por exemplo, se um Pod A deseja se comunicar com um Pod B, é o Kube-Proxy o responsável por direcionar
            essa comunicação. Tal direcionamento se dá através do  -->